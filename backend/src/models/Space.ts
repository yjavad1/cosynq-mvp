import mongoose, { Document, Schema, Types } from 'mongoose';

export type SpaceType = 'Hot Desk' | 'Meeting Room' | 'Private Office';
export type SpaceStatus = 'Available' | 'Occupied' | 'Maintenance' | 'Out of Service' | 'Reserved' | 'Cleaning';

export interface IWorkingHours {
  day: 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';
  isOpen: boolean;
  openTime?: string; // Format: "HH:MM" (24-hour)
  closeTime?: string; // Format: "HH:MM" (24-hour)
}

export interface ISpaceRates {
  hourly?: number;
  daily?: number;
  weekly?: number;
  monthly?: number;
  currency: string;
}

export interface ISpace extends Document {
  _id: Types.ObjectId;
  organizationId: Types.ObjectId;
  
  // Hierarchy References - New multi-level structure
  locationId?: Types.ObjectId; // Reference to Location
  productTypeId?: Types.ObjectId; // Reference to ProductType
  
  // Basic Information
  name: string;
  description?: string;
  type: SpaceType; // Maintained for backward compatibility
  status: SpaceStatus;
  
  // Capacity and Physical Properties
  capacity: number | null; // null => unlimited
  hasPooledUnits: boolean; // default false
  area?: number; // in square feet/meters
  floor?: string;
  room?: string;
  
  // Position and Identification
  spaceCode?: string; // Auto-generated or manual code like "MC001", "TR-A-205"
  position?: {
    coordinates?: {
      x: number; // Position on floor plan
      y: number;
    };
    zone?: string; // e.g., "North Wing", "Central Area"
    section?: string; // e.g., "A", "B", "C"
  };
  
  // Pricing - Can be overridden from ProductType
  rates: ISpaceRates;
  useProductTypePricing?: boolean; // If true, inherit pricing from ProductType
  
  // Amenities and Features - Can be supplemented by ProductType
  amenities: string[];
  equipment: string[];
  inheritProductTypeAmenities?: boolean; // If true, merge with ProductType amenities
  
  // Availability and Hours - Can inherit from ProductType or Location
  workingHours: IWorkingHours[];
  useProductTypeHours?: boolean; // If true, inherit from ProductType operating hours
  isActive: boolean;
  
  // Booking Configuration - Can inherit from ProductType
  minimumBookingDuration: number; // in minutes
  maximumBookingDuration: number; // in minutes
  advanceBookingLimit: number; // in days
  allowSameDayBooking: boolean;
  useProductTypeBookingRules?: boolean; // If true, inherit from ProductType
  
  // Images and Media
  images?: string[];
  
  // Analytics and Tracking
  stats?: {
    totalBookings?: number;
    totalBookingHours?: number;
    averageBookingDuration?: number; // in minutes
    occupancyRate?: number; // percentage
    revenue?: number;
    lastBookingDate?: Date;
    maintenanceScheduled?: Date;
    customerRating?: number; // 1-5 stars
  };
  
  // Metadata
  autoGenerated?: boolean; // True if generated from ProductType
  generationSource?: {
    productTypeId: Types.ObjectId;
    generatedAt: Date;
    sequence: number; // For naming like MC001, MC002
  };
  
  createdBy: Types.ObjectId;
  updatedBy: Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
  
  // Instance methods
  isAvailableAt(dateTime: Date): boolean;
  getWorkingHoursForDay(day: string): IWorkingHours | null;
  getRateForDuration(durationMinutes: number): { rate: number; type: string };
  getEffectiveAmenities(): Promise<string[]>;
  getEffectivePricing(): Promise<any>;
  syncWithProductType(): Promise<void>;
}

const workingHoursSchema = new Schema<IWorkingHours>({
  day: {
    type: String,
    enum: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'],
    required: true
  },
  isOpen: {
    type: Boolean,
    required: true,
    default: true
  },
  openTime: {
    type: String,
    match: /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/,
    default: '09:00'
  },
  closeTime: {
    type: String,
    match: /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/,
    default: '17:00'
  }
}, { _id: false });

const spaceRatesSchema = new Schema<ISpaceRates>({
  hourly: {
    type: Number,
    min: 0
  },
  daily: {
    type: Number,
    min: 0
  },
  weekly: {
    type: Number,
    min: 0
  },
  monthly: {
    type: Number,
    min: 0
  },
  currency: {
    type: String,
    required: true,
    default: 'USD',
    uppercase: true,
    length: 3
  }
}, { _id: false });

const spaceSchema = new Schema<ISpace>({
  organizationId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  locationId: {
    type: Schema.Types.ObjectId,
    ref: 'Location',
    index: true
  },
  productTypeId: {
    type: Schema.Types.ObjectId,
    ref: 'ProductType',
    index: true
  },
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 100
  },
  description: {
    type: String,
    trim: true,
    maxlength: 1000
  },
  type: {
    type: String,
    enum: ['Hot Desk', 'Meeting Room', 'Private Office'],
    required: true,
    index: true
  },
  status: {
    type: String,
    enum: ['Available', 'Occupied', 'Maintenance', 'Out of Service', 'Reserved', 'Cleaning'],
    default: 'Available',
    index: true
  },
  capacity: {
    type: Number,
    required: false,
    min: 1,
    max: 100,
    default: null // null => unlimited
  },
  hasPooledUnits: {
    type: Boolean,
    default: false
  },
  area: {
    type: Number,
    min: 0
  },
  floor: {
    type: String,
    trim: true,
    maxlength: 10
  },
  room: {
    type: String,
    trim: true,
    maxlength: 20
  },
  spaceCode: {
    type: String,
    trim: true,
    uppercase: true,
    maxlength: 50
  },
  position: {
    coordinates: {
      x: {
        type: Number,
        min: 0,
        max: 10000
      },
      y: {
        type: Number,
        min: 0,
        max: 10000
      }
    },
    zone: {
      type: String,
      trim: true,
      maxlength: 100
    },
    section: {
      type: String,
      trim: true,
      maxlength: 50
    }
  },
  rates: {
    type: spaceRatesSchema,
    required: true
  },
  useProductTypePricing: {
    type: Boolean,
    default: false
  },
  amenities: [{
    type: String,
    trim: true,
    maxlength: 50
  }],
  equipment: [{
    type: String,
    trim: true,
    maxlength: 50
  }],
  inheritProductTypeAmenities: {
    type: Boolean,
    default: true
  },
  workingHours: {
    type: [workingHoursSchema],
    required: true,
    validate: {
      validator: function(hours: IWorkingHours[]) {
        const days = hours.map(h => h.day);
        return days.length === new Set(days).size; // Ensure unique days
      },
      message: 'Each day can only appear once in working hours'
    }
  },
  useProductTypeHours: {
    type: Boolean,
    default: true
  },
  isActive: {
    type: Boolean,
    default: true,
    index: true
  },
  minimumBookingDuration: {
    type: Number,
    default: 60, // 1 hour in minutes
    min: 15,
    max: 1440 // 24 hours
  },
  maximumBookingDuration: {
    type: Number,
    default: 480, // 8 hours in minutes
    min: 15,
    max: 1440 // 24 hours
  },
  advanceBookingLimit: {
    type: Number,
    default: 30, // 30 days
    min: 0,
    max: 365
  },
  allowSameDayBooking: {
    type: Boolean,
    default: true
  },
  useProductTypeBookingRules: {
    type: Boolean,
    default: true
  },
  images: [{
    type: String,
    trim: true
  }],
  stats: {
    totalBookings: {
      type: Number,
      default: 0,
      min: 0
    },
    totalBookingHours: {
      type: Number,
      default: 0,
      min: 0
    },
    averageBookingDuration: {
      type: Number,
      min: 0
    },
    occupancyRate: {
      type: Number,
      min: 0,
      max: 100
    },
    revenue: {
      type: Number,
      default: 0,
      min: 0
    },
    lastBookingDate: Date,
    maintenanceScheduled: Date,
    customerRating: {
      type: Number,
      min: 0,
      max: 5
    }
  },
  autoGenerated: {
    type: Boolean,
    default: false
  },
  generationSource: {
    productTypeId: {
      type: Schema.Types.ObjectId,
      ref: 'ProductType'
    },
    generatedAt: Date,
    sequence: Number
  },
  createdBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  updatedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

// Instance methods
spaceSchema.methods.isAvailableAt = function(dateTime: Date): boolean {
  if (!this.isActive || this.status !== 'Available') {
    return false;
  }
  
  const dayName = dateTime.toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase();
  const workingHours = this.getWorkingHoursForDay(dayName);
  
  if (!workingHours || !workingHours.isOpen) {
    return false;
  }
  
  const timeString = dateTime.toTimeString().substring(0, 5);
  return timeString >= workingHours.openTime && timeString <= workingHours.closeTime;
};

spaceSchema.methods.getWorkingHoursForDay = function(day: string): IWorkingHours | null {
  const dayLower = day.toLowerCase();
  return this.workingHours.find((wh: IWorkingHours) => wh.day === dayLower) || null;
};

spaceSchema.methods.getRateForDuration = function(durationMinutes: number): { rate: number; type: string } {
  const durationHours = durationMinutes / 60;
  const durationDays = durationMinutes / (60 * 24);
  
  // Prioritize the most cost-effective rate for the customer
  if (this.rates.monthly && durationDays >= 30) {
    return { rate: this.rates.monthly, type: 'monthly' };
  }
  
  if (this.rates.weekly && durationDays >= 7) {
    return { rate: this.rates.weekly, type: 'weekly' };
  }
  
  if (this.rates.daily && durationHours >= 8) {
    return { rate: this.rates.daily, type: 'daily' };
  }
  
  if (this.rates.hourly) {
    return { rate: this.rates.hourly * Math.ceil(durationHours), type: 'hourly' };
  }
  
  // Fallback to daily rate if available
  if (this.rates.daily) {
    return { rate: this.rates.daily, type: 'daily' };
  }
  
  return { rate: 0, type: 'free' };
};

// New instance methods for ProductType integration
spaceSchema.methods.getEffectiveAmenities = async function(): Promise<string[]> {
  let amenities = [...this.amenities];
  
  if (this.inheritProductTypeAmenities && this.productTypeId) {
    try {
      const ProductType = mongoose.model('ProductType');
      const productType = await ProductType.findById(this.productTypeId);
      
      if (productType && productType.amenities) {
        // Merge included amenities from ProductType
        if (productType.amenities.included) {
          amenities = [...amenities, ...productType.amenities.included];
        }
        
        // Add required amenities from ProductType
        if (productType.amenities.required) {
          amenities = [...amenities, ...productType.amenities.required];
        }
      }
    } catch (error) {
      console.error('Error fetching ProductType amenities:', error);
    }
  }
  
  // Remove duplicates
  return [...new Set(amenities)];
};

spaceSchema.methods.getEffectivePricing = async function(): Promise<any> {
  if (this.useProductTypePricing && this.productTypeId) {
    try {
      const ProductType = mongoose.model('ProductType');
      const productType = await ProductType.findById(this.productTypeId);
      
      if (productType && productType.pricing) {
        return productType.pricing;
      }
    } catch (error) {
      console.error('Error fetching ProductType pricing:', error);
    }
  }
  
  // Return space-specific rates converted to ProductType format
  return {
    type: 'hourly',
    basePrice: this.rates.hourly,
    currency: this.rates.currency,
    tiers: []
  };
};

spaceSchema.methods.syncWithProductType = async function(): Promise<void> {
  if (!this.productTypeId) return;
  
  try {
    const ProductType = mongoose.model('ProductType');
    const productType = await ProductType.findById(this.productTypeId);
    
    if (!productType) return;
    
    // Sync capacity if not manually set
    if (this.capacity === 1) { // Default capacity, likely not manually set
      this.capacity = productType.capacity.optimalCapacity;
    }
    
    // Sync area if available from ProductType
    if (productType.floorSpace && !this.area) {
      this.area = productType.floorSpace;
    }
    
    // Sync booking rules if using ProductType rules
    if (this.useProductTypeBookingRules && productType.pricing) {
      if (productType.pricing.minimumDuration) {
        this.minimumBookingDuration = productType.pricing.minimumDuration;
      }
      if (productType.pricing.maximumDuration) {
        this.maximumBookingDuration = productType.pricing.maximumDuration;
      }
      if (productType.pricing.advanceBookingRequired !== undefined) {
        this.advanceBookingLimit = Math.ceil(productType.pricing.advanceBookingRequired / 24); // Convert hours to days
      }
    }
    
    await this.save();
  } catch (error) {
    console.error('Error syncing with ProductType:', error);
  }
};

// Indexes for performance and multi-level hierarchy
spaceSchema.index({ organizationId: 1, type: 1 });
spaceSchema.index({ organizationId: 1, status: 1 });
spaceSchema.index({ organizationId: 1, isActive: 1 });
spaceSchema.index({ organizationId: 1, capacity: 1 });
spaceSchema.index({ organizationId: 1, 'rates.hourly': 1 });
spaceSchema.index({ organizationId: 1, 'rates.daily': 1 });
spaceSchema.index({ organizationId: 1, amenities: 1 });

// New hierarchy indexes
spaceSchema.index({ organizationId: 1, locationId: 1 });
spaceSchema.index({ organizationId: 1, productTypeId: 1 });
spaceSchema.index({ organizationId: 1, locationId: 1, productTypeId: 1 });
spaceSchema.index({ organizationId: 1, locationId: 1, status: 1 });
spaceSchema.index({ organizationId: 1, productTypeId: 1, isActive: 1 });
spaceSchema.index({ organizationId: 1, autoGenerated: 1 });
spaceSchema.index({ organizationId: 1, 'generationSource.productTypeId': 1 });

// General indexes
spaceSchema.index({ createdAt: -1 });
spaceSchema.index({ updatedAt: -1 });

// Unique constraints
spaceSchema.index({ organizationId: 1, name: 1 }, { unique: true });
spaceSchema.index({ organizationId: 1, spaceCode: 1 }, { unique: true, sparse: true }); // Sparse because spaceCode is optional

export const Space = mongoose.model<ISpace>('Space', spaceSchema);